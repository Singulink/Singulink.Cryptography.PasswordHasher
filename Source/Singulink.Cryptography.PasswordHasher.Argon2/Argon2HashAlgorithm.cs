using System.Diagnostics;

using Isopoh.Cryptography.Argon2;
using IArgon2 = Isopoh.Cryptography.Argon2;

namespace Singulink.Cryptography;

/// <summary>
/// Provides Argon2i, Argon2d and Argon2id password hashing functionality.
/// </summary>
public sealed class Argon2HashAlgorithm : PasswordHashAlgorithm
{
    /// <summary>
    /// Gets the Argon2 algorithm type.
    /// </summary>
    public Argon2Type Type { get; }

    /// <summary>
    /// Gets the Argon2 algorithm version.
    /// </summary>
    public Argon2Version Version { get; }

    /// <summary>
    /// Gets the number of lanes used while processing the hash.
    /// </summary>
    public int Parallelism { get; }

    /// <summary>
    /// Gets the amount of memory (in MB) used while processing the hash.
    /// </summary>
    public int MemorySize { get; }

    /// <summary>
    /// Gets the hash output size in bytes.
    /// </summary>
    public int HashLength { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Argon2HashAlgorithm"/> class with the specified parameters.
    /// </summary>
    /// <param name="type">The Argon2 algorithm type to use.</param>
    /// <param name="version">The Argon2 version to use.</param>
    /// <param name="parallelism">The number of lanes to use while processing the hash.</param>
    /// <param name="memorySize">The amount of memory (in MB) to use while processing the hash.</param>
    /// <param name="hashLength">The size of the output hash (in bytes). 16 bytes is recommended for password hashing.</param>
    public Argon2HashAlgorithm(Argon2Type type, Argon2Version version, int parallelism, int memorySize, int hashLength = 16)
        : base($"{type}V{(int)version}-{hashLength * 8}-{parallelism}P-{memorySize}MB")
    {
        // Inputs:
        //    password (P):       Bytes (0..2^32-1)    Password (or message) to be hashed
        //    salt (S):           Bytes (8..2^32-1)    Salt (16 bytes recommended for password hashing)
        //    parallelism (p):    Number (1..2^24-1)   Degree of parallelism (i.e. number of threads)
        //    tagLength (T):      Number (4..2^32-1)   Desired number of returned bytes
        //    memorySizeKB (m):   Number (8p..2^32-1)  Amount of memory (in kibibytes) to use
        //    iterations (t):     Number (1..2^32-1)   Number of iterations to perform
        //    version (v):        Number (0x13)       The current version is 0x13 (19 decimal)
        //    key (K):            Bytes (0..2^32-1)    Optional key (Errata: PDF says 0..32 bytes, RFC says 0..232 bytes)
        //    associatedData (X): Bytes (0..2^32-1)    Optional arbitrary extra data
        //    hashType (y):       Number (0=Argon2d, 1=Argon2i, 2=Argon2id)
        // Output:
        //    tag:                Bytes (tagLength)   The resulting generated bytes, tagLength bytes long

        if (!Enum.IsDefined(typeof(Argon2Type), type))
            throw new ArgumentOutOfRangeException(nameof(type));

        if (!Enum.IsDefined(typeof(Argon2Version), version))
            throw new ArgumentOutOfRangeException(nameof(version));

        if (parallelism < 1)
            throw new ArgumentOutOfRangeException(nameof(parallelism));

        if (memorySize * 1024 < parallelism * 8 || memorySize > 4194303)
            throw new ArgumentOutOfRangeException(nameof(memorySize));

        if (hashLength < 4)
            throw new ArgumentOutOfRangeException(nameof(hashLength));

        Parallelism = parallelism;
        MemorySize = memorySize;
        HashLength = hashLength;
    }

    /// <inheritdoc/>
    public override byte[] Hash(byte[] password, byte[] salt, int iterations)
    {
        var config = new Argon2Config {
            Type = (IArgon2.Argon2Type)Type,
            Version = (IArgon2.Argon2Version)Version,
            Password = password,
            Salt = salt,
            TimeCost = iterations,
            Lanes = Parallelism,
            Threads = Parallelism,
            HashLength = HashLength,
            MemoryCost = MemorySize * 1024,
        };

        using var argon2 = new Argon2(config);
        using var result = argon2.Hash();
        Debug.Assert(result.Buffer.Length == HashLength, "Unexpected hash length.");

        return (byte[])result.Buffer.Clone();
    }
}